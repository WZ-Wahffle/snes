#include "spc_mmu.h"
#include "types.h"

extern cpu_t cpu;
extern spc_t spc;

uint8_t ipl_boot_rom[] = {
    0xcd, 0xef, 0xbd, 0xe8, 0x00, 0xc6, 0x1d, 0xd0, 0xfc, 0x8f, 0xaa,
    0xf4, 0x8f, 0xbb, 0xf5, 0x78, 0xcc, 0xf4, 0xd0, 0xfb, 0x2f, 0x19,
    0xeb, 0xf4, 0xd0, 0xfc, 0x7e, 0xf4, 0xd0, 0x0b, 0xe4, 0xf5, 0xcb,
    0xf4, 0xd7, 0x00, 0xfc, 0xd0, 0xf3, 0xab, 0x01, 0x10, 0xef, 0x7e,
    0xf4, 0x10, 0xeb, 0xba, 0xf6, 0xda, 0x00, 0xba, 0xf4, 0xc4, 0xf4,
    0xdd, 0x5d, 0xd0, 0xdb, 0x1f, 0x00, 0x00, 0xc0, 0xff};

uint8_t spc_mmu_read(uint16_t addr) {
    if (addr >= 0xffc0) {
        return ipl_boot_rom[addr - 0xffc0];
    } else if (addr >= 0xf0 && addr < 0x100) {
        switch (addr) {
            case 0xf4:
            case 0xf5:
            case 0xf6:
            case 0xf7:
            return cpu.memory.apu_io[addr - 0xf4];
        default:
            UNREACHABLE_SWITCH(addr);
        }
    }

    return spc.memory.ram[addr];
}

void spc_mmu_write(uint16_t addr, uint8_t val) { spc.memory.ram[addr] = val; }
